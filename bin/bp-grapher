#!/usr/bin/env python
import argparse
import pkgutil
import pprint
import json
import os
import benchpress.grapher
from benchpress import result_parser

if __name__ == "__main__":

    graph_types = {}    # Auto-load all graph-modules from grapher/*
                        # The graph-class must be a capilized version of the
                        # filename
    for _, module, _ in pkgutil.iter_modules([os.path.dirname(benchpress.grapher.__file__)]):
        if module == 'graph':
            continue

        module_caps = module.capitalize()
        m = __import__("benchpress.grapher.%s" % module, globals(), locals(), [module_caps], -1)
        try:
            graph_types[module] = m.__dict__[module_caps]
        except KeyError:
            pass

    parser = argparse.ArgumentParser(
        description = 'Generate different types of graphs.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument(
        'results',
        help='Path to benchmark results.'
    )
    parser.add_argument(
        '--output-path',
        default=".",
        help='Where to store generated graphs.'
    )
    parser.add_argument(
        '--title',
        default="graph",
        help='The title of the graph.'
    )
    parser.add_argument(
        '--fn-pattern',
        default='{title}.{ext}',
        help="The output filename pattern."
    )
    parser.add_argument(
        '--formats',
        default=['png'],
        nargs='+',
        help="Output file-format(s) of the generated graph(s)."
    )
    parser.add_argument(
        '--type',
        default=[[gt for gt in graph_types][0]],
        nargs=1,
        choices=[gt for gt in graph_types],
        help="The type of graph to generate"
    )
    parser.add_argument(
        '--data-to-display',
        default=[[t[1] for t in result_parser.tokens][0]],
        nargs=1,
        choices=[t[1] for t in result_parser.tokens],
        help="The data to display in the generated graph(s)"
    )
    parser.add_argument(
        '--stacks-to-display',
        metavar="RegEx",
        default=".*",
        help="All stacks that match the RegEx are showed in the generated graph(s)."
    )
    parser.add_argument(
        '--stacks-not-to-display',
        metavar="RegEx",
        default="NotIncluded",
        help="All stacks that match the RegEx are not showed in the generated graph(s)."
    )
    parser.add_argument(
        '--scripts-to-display',
        metavar="RegEx",
        default=".*",
        help="All scripts that match the RegEx are showed in the generated graph(s)."
    )
    parser.add_argument(
        '--scripts-not-to-display',
        metavar="RegEx",
        default="NotIncluded",
        help="All scripts that match the RegEx are NOT showed in the generated graph(s)."
    )
    parser.add_argument(
        '--warmups',
        default=0,
        type=int,
        help="Specify the amount of samples from warm-up rounds."
    )
    parser.add_argument(
        '--baseline',
        default=None,
        help='Baseline label for relative graphs.'
    )
    parser.add_argument(
        '--order',
        default=None,
        nargs='+',
        help='Ordering of the ticks.'
    )
    parser.add_argument(
        '--ymax',
        default=None,
        help="Max value of the y-axis"
    )
    parser.add_argument(
        '--ymin',
        default=None,
        help="Min value of the y-axis"
    )
    parser.add_argument(
        '--ylog',
        default=False,
        action='store_true',
        help="Makes the y-axis logarithmic"
    )
    parser.add_argument(
        '--xticklabel-rotation',
        default=90,
        type=int,
        help="The rotation of the tick label on the x-axis"
    )
    parser.add_argument(
        '--fontsize',
        default=12,
        type=int,
        help="Fontsize"
    )
    parser.add_argument(
        '--stack-map',
        default=None,
        metavar="RegEx:label,...,RegEx:label",
        help="Comma separated list of original-to-new-stack names"
    )
    parser.add_argument(
        '--script-map',
        default=None,
        metavar="RegEx:label,...,RegEx:label",
        help="Comma separated list of original-to-new-script names"
    )

    args = parser.parse_args()
    args.type = args.type.pop()
    args.data_to_display = args.data_to_display.pop()
    args.output_path = os.path.expandvars(os.path.expanduser(args.output_path))

    #Let's parse the stack map
    stack_map = []
    if args.stack_map is not None:
        for label in args.stack_map.split(","):
            if ":" not in label:
                raise ValueError("--stack-map expects syntax: 'old_label:new_labe'")
            (old, new) = label.split(":")
            stack_map.append((old, new))
    args.stack_map = stack_map

    #Let's parse the script map
    script_map = []
    if args.script_map is not None:
        for label in args.script_map.split(","):
            if ":" not in label:
                raise ValueError("--script-map expects syntax: 'old_label:new_labe'")
            (old, new) = label.split(":")
            script_map.append((old, new))
    args.script_map = script_map

    g = graph_types[args.type](args)
    g.render()

